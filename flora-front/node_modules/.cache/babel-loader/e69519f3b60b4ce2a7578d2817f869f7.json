{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/ui-keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { createPair } from '@polkadot/keyring';\nimport { chains } from '@polkadot/ui-settings';\nimport { bnToBn, hexToU8a, isHex, isString, stringToU8a, u8aSorted, u8aToString } from '@polkadot/util';\nimport { base64Decode, createKeyMulti, jsonDecrypt, jsonEncrypt } from '@polkadot/util-crypto';\nimport { env } from \"./observable/env.js\";\nimport { Base } from \"./Base.js\";\nimport { accountKey, accountRegex, addressKey, addressRegex, contractKey, contractRegex } from \"./defaults.js\";\nimport { KeyringOption } from \"./options/index.js\";\nconst RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.\n// Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered\n// from the API after the chain is received\n\nvar _stores = /*#__PURE__*/_classPrivateFieldLooseKey(\"stores\");\n\nexport class Keyring extends Base {\n  constructor(...args) {\n    super(...args);\n    this.keyringOption = new KeyringOption();\n    Object.defineProperty(this, _stores, {\n      writable: true,\n      value: {\n        account: () => this.accounts,\n        address: () => this.addresses,\n        contract: () => this.contracts\n      }\n    });\n  }\n\n  addExternal(address, meta = {}) {\n    const pair = this.keyring.addFromAddress(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isExternal: true\n    }), null);\n    return {\n      json: this.saveAccount(pair),\n      pair\n    };\n  }\n\n  addHardware(address, hardwareType, meta = {}) {\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      hardwareType,\n      isHardware: true\n    }));\n  }\n\n  addMultisig(addresses, threshold, meta = {}) {\n    const address = createKeyMulti(addresses, threshold); // we could use `sortAddresses`, but rather use internal encode/decode so we are 100%\n\n    const who = u8aSorted(addresses.map(who => this.decodeAddress(who))).map(who => this.encodeAddress(who));\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isMultisig: true,\n      threshold: bnToBn(threshold).toNumber(),\n      who\n    }));\n  }\n\n  addPair(pair, password) {\n    this.keyring.addPair(pair);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  addUri(suri, password, meta = {}, type) {\n    const pair = this.keyring.addFromUri(suri, meta, type);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  backupAccount(pair, password) {\n    if (!pair.isLocked) {\n      pair.lock();\n    }\n\n    pair.decodePkcs8(password);\n    return pair.toJson(password);\n  }\n\n  async backupAccounts(addresses, password) {\n    const accountPromises = addresses.map(address => {\n      return new Promise(resolve => {\n        this._store.get(accountKey(address), resolve);\n      });\n    });\n    const accounts = await Promise.all(accountPromises);\n    return _objectSpread(_objectSpread({}, jsonEncrypt(stringToU8a(JSON.stringify(accounts)), ['batch-pkcs8'], password)), {}, {\n      accounts: accounts.map(account => ({\n        address: account.address,\n        meta: account.meta\n      }))\n    });\n  }\n\n  createFromJson(json, meta = {}) {\n    return this.keyring.createFromJson(_objectSpread(_objectSpread({}, json), {}, {\n      meta: _objectSpread(_objectSpread({}, json.meta || {}), {}, {\n        meta\n      })\n    }));\n  }\n\n  createFromUri(suri, meta = {}, type) {\n    return this.keyring.createFromUri(suri, meta, type);\n  }\n\n  encryptAccount(pair, password) {\n    const json = pair.toJson(password);\n    json.meta.whenEdited = Date.now();\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  forgetAccount(address) {\n    this.keyring.removePair(address);\n    this.accounts.remove(this._store, address);\n  }\n\n  forgetAddress(address) {\n    this.addresses.remove(this._store, address);\n  }\n\n  forgetContract(address) {\n    this.contracts.remove(this._store, address);\n  }\n\n  getAccount(address) {\n    return this.getAddress(address, 'account');\n  }\n\n  getAccounts() {\n    const available = this.accounts.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => env.isDevelopment() || account.meta.isTesting !== true);\n  }\n\n  getAddress(_address, type = null) {\n    const address = isString(_address) ? _address : this.encodeAddress(_address);\n    const publicKey = this.decodeAddress(address);\n    const stores = type ? [_classPrivateFieldLooseBase(this, _stores)[_stores][type]] : Object.values(_classPrivateFieldLooseBase(this, _stores)[_stores]);\n    const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);\n    return info && {\n      address,\n      meta: info.json.meta,\n      publicKey\n    };\n  }\n\n  getAddresses() {\n    const available = this.addresses.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address));\n  }\n\n  getContract(address) {\n    return this.getAddress(address, 'contract');\n  }\n\n  getContracts() {\n    const available = this.contracts.subject.getValue();\n    return Object.entries(available).filter(([, {\n      json: {\n        meta: {\n          contract\n        }\n      }\n    }]) => !!contract && contract.genesisHash === this.genesisHash).map(([address]) => this.getContract(address));\n  }\n\n  rewriteKey(json, key, hexAddr, creator) {\n    if (hexAddr.substr(0, 2) === '0x') {\n      return;\n    }\n\n    this._store.remove(key);\n\n    this._store.set(creator(hexAddr), json);\n  }\n\n  loadAccount(json, key) {\n    if (!json.meta.isTesting && json.encoded) {\n      // FIXME Just for the transition period (ignoreChecksum)\n      const pair = this.keyring.addFromJson(json, true);\n      this.accounts.add(this._store, pair.address, json, pair.type);\n    }\n\n    const [, hexAddr] = key.split(':');\n    this.rewriteKey(json, key, hexAddr.trim(), accountKey);\n  }\n\n  loadAddress(json, key) {\n    const {\n      isRecent,\n      whenCreated = 0\n    } = json.meta;\n\n    if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {\n      this._store.remove(key);\n\n      return;\n    } // We assume anything hex that is not 32bytes (64 + 2 bytes hex) is an Ethereum-like address\n    // (this caters for both H160 addresses as well as full or compressed publicKeys) - in the case\n    // of both ecdsa and ethereum, we keep it as-is\n\n\n    const address = isHex(json.address) && json.address.length !== 66 ? json.address : this.encodeAddress(isHex(json.address) ? hexToU8a(json.address) // FIXME Just for the transition period (ignoreChecksum)\n    : this.decodeAddress(json.address, true));\n    const [, hexAddr] = key.split(':');\n    this.addresses.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, addressKey);\n  }\n\n  loadContract(json, key) {\n    const address = this.encodeAddress(this.decodeAddress(json.address));\n    const [, hexAddr] = key.split(':'); // move genesisHash to top-level (TODO Remove from contracts section?)\n\n    json.meta.genesisHash = json.meta.genesisHash || json.meta.contract && json.meta.contract.genesisHash;\n    this.contracts.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, contractKey);\n  }\n\n  loadInjected(address, meta, type) {\n    const json = {\n      address,\n      meta: _objectSpread(_objectSpread({}, meta), {}, {\n        isInjected: true\n      })\n    };\n    const pair = this.keyring.addFromAddress(address, json.meta, null, type);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  allowGenesis(json) {\n    if (json && json.meta && this.genesisHash) {\n      const hashes = Object.values(chains).find(hashes => hashes.includes(this.genesisHash || '')) || [this.genesisHash];\n\n      if (json.meta.genesisHash) {\n        return hashes.includes(json.meta.genesisHash);\n      } else if (json.meta.contract) {\n        return hashes.includes(json.meta.contract.genesisHash);\n      }\n    }\n\n    return true;\n  }\n\n  loadAll(options, injected = []) {\n    super.initKeyring(options);\n\n    this._store.all((key, json) => {\n      if (options.filter ? options.filter(json) : true) {\n        try {\n          if (this.allowGenesis(json)) {\n            if (accountRegex.test(key)) {\n              this.loadAccount(json, key);\n            } else if (addressRegex.test(key)) {\n              this.loadAddress(json, key);\n            } else if (contractRegex.test(key)) {\n              this.loadContract(json, key);\n            }\n          }\n        } catch (error) {// ignore\n        }\n      }\n    });\n\n    injected.forEach(account => {\n      if (this.allowGenesis(account)) {\n        try {\n          this.loadInjected(account.address, account.meta, account.type);\n        } catch (error) {// ignore\n        }\n      }\n    });\n    this.keyringOption.init(this);\n  }\n\n  restoreAccount(json, password) {\n    const cryptoType = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';\n    const encType = Array.isArray(json.encoding.type) ? json.encoding.type : [json.encoding.type];\n    const pair = createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey: this.decodeAddress(json.address, true)\n    }, json.meta, isHex(json.encoded) ? hexToU8a(json.encoded) : base64Decode(json.encoded), encType); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)\n\n    pair.decodePkcs8(password);\n    this.addPair(pair, password);\n    pair.lock();\n    return pair;\n  }\n\n  restoreAccounts(json, password) {\n    const accounts = JSON.parse(u8aToString(jsonDecrypt(json, password)));\n    accounts.forEach(account => {\n      this.loadAccount(account, accountKey(account.address));\n    });\n  }\n\n  saveAccount(pair, password) {\n    this.addTimestamp(pair);\n    const json = pair.toJson(password);\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n    return json;\n  }\n\n  saveAccountMeta(pair, meta) {\n    const address = pair.address;\n\n    this._store.get(accountKey(address), json => {\n      pair.setMeta(meta);\n      json.meta = pair.meta;\n      this.accounts.add(this._store, address, json, pair.type);\n    });\n  }\n\n  saveAddress(address, meta, type = 'address') {\n    const available = this.addresses.subject.getValue();\n    const json = available[address] && available[address].json || {\n      address,\n      meta: {\n        isRecent: undefined,\n        whenCreated: Date.now()\n      }\n    };\n    Object.keys(meta).forEach(key => {\n      json.meta[key] = meta[key];\n    });\n    delete json.meta.isRecent;\n\n    _classPrivateFieldLooseBase(this, _stores)[_stores][type]().add(this._store, address, json);\n\n    return json;\n  }\n\n  saveContract(address, meta) {\n    return this.saveAddress(address, meta, 'contract');\n  }\n\n  saveRecent(address) {\n    const available = this.addresses.subject.getValue();\n\n    if (!available[address]) {\n      this.addresses.add(this._store, address, {\n        address,\n        meta: {\n          genesisHash: this.genesisHash,\n          isRecent: true,\n          whenCreated: Date.now()\n        }\n      });\n    }\n\n    return this.addresses.subject.getValue()[address];\n  }\n\n}","map":{"version":3,"sources":["/home/arieiro/rust/Flora.Network/flora-front/node_modules/@polkadot/ui-keyring/Keyring.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","createPair","chains","bnToBn","hexToU8a","isHex","isString","stringToU8a","u8aSorted","u8aToString","base64Decode","createKeyMulti","jsonDecrypt","jsonEncrypt","env","Base","accountKey","accountRegex","addressKey","addressRegex","contractKey","contractRegex","KeyringOption","RECENT_EXPIRY","_stores","Keyring","constructor","args","keyringOption","writable","value","account","accounts","address","addresses","contract","contracts","addExternal","meta","pair","keyring","addFromAddress","isExternal","json","saveAccount","addHardware","hardwareType","isHardware","addMultisig","threshold","who","map","decodeAddress","encodeAddress","isMultisig","toNumber","addPair","password","addUri","suri","type","addFromUri","backupAccount","isLocked","lock","decodePkcs8","toJson","backupAccounts","accountPromises","Promise","resolve","_store","get","all","JSON","stringify","createFromJson","createFromUri","encryptAccount","whenEdited","Date","now","addFromJson","add","forgetAccount","removePair","remove","forgetAddress","forgetContract","getAccount","getAddress","getAccounts","available","subject","getValue","isDevelopment","isTesting","_address","publicKey","stores","values","info","reduce","lastInfo","store","undefined","getAddresses","getContract","getContracts","entries","genesisHash","rewriteKey","hexAddr","creator","substr","set","loadAccount","encoded","split","trim","loadAddress","isRecent","whenCreated","loadContract","loadInjected","isInjected","allowGenesis","hashes","find","includes","loadAll","options","injected","initKeyring","test","error","init","restoreAccount","cryptoType","Array","isArray","encoding","content","encType","toSS58","restoreAccounts","parse","addTimestamp","saveAccountMeta","setMeta","saveAddress","saveContract","saveRecent"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/ui-keyring authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { createPair } from '@polkadot/keyring';\nimport { chains } from '@polkadot/ui-settings';\nimport { bnToBn, hexToU8a, isHex, isString, stringToU8a, u8aSorted, u8aToString } from '@polkadot/util';\nimport { base64Decode, createKeyMulti, jsonDecrypt, jsonEncrypt } from '@polkadot/util-crypto';\nimport { env } from \"./observable/env.js\";\nimport { Base } from \"./Base.js\";\nimport { accountKey, accountRegex, addressKey, addressRegex, contractKey, contractRegex } from \"./defaults.js\";\nimport { KeyringOption } from \"./options/index.js\";\nconst RECENT_EXPIRY = 24 * 60 * 60; // No accounts (or test accounts) should be loaded until after the chain determination.\n// Chain determination occurs outside of Keyring. Loading `keyring.loadAll({ type: 'ed25519' | 'sr25519' })` is triggered\n// from the API after the chain is received\n\nvar _stores = /*#__PURE__*/_classPrivateFieldLooseKey(\"stores\");\n\nexport class Keyring extends Base {\n  constructor(...args) {\n    super(...args);\n    this.keyringOption = new KeyringOption();\n    Object.defineProperty(this, _stores, {\n      writable: true,\n      value: {\n        account: () => this.accounts,\n        address: () => this.addresses,\n        contract: () => this.contracts\n      }\n    });\n  }\n\n  addExternal(address, meta = {}) {\n    const pair = this.keyring.addFromAddress(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isExternal: true\n    }), null);\n    return {\n      json: this.saveAccount(pair),\n      pair\n    };\n  }\n\n  addHardware(address, hardwareType, meta = {}) {\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      hardwareType,\n      isHardware: true\n    }));\n  }\n\n  addMultisig(addresses, threshold, meta = {}) {\n    const address = createKeyMulti(addresses, threshold); // we could use `sortAddresses`, but rather use internal encode/decode so we are 100%\n\n    const who = u8aSorted(addresses.map(who => this.decodeAddress(who))).map(who => this.encodeAddress(who));\n    return this.addExternal(address, _objectSpread(_objectSpread({}, meta), {}, {\n      isMultisig: true,\n      threshold: bnToBn(threshold).toNumber(),\n      who\n    }));\n  }\n\n  addPair(pair, password) {\n    this.keyring.addPair(pair);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  addUri(suri, password, meta = {}, type) {\n    const pair = this.keyring.addFromUri(suri, meta, type);\n    return {\n      json: this.saveAccount(pair, password),\n      pair\n    };\n  }\n\n  backupAccount(pair, password) {\n    if (!pair.isLocked) {\n      pair.lock();\n    }\n\n    pair.decodePkcs8(password);\n    return pair.toJson(password);\n  }\n\n  async backupAccounts(addresses, password) {\n    const accountPromises = addresses.map(address => {\n      return new Promise(resolve => {\n        this._store.get(accountKey(address), resolve);\n      });\n    });\n    const accounts = await Promise.all(accountPromises);\n    return _objectSpread(_objectSpread({}, jsonEncrypt(stringToU8a(JSON.stringify(accounts)), ['batch-pkcs8'], password)), {}, {\n      accounts: accounts.map(account => ({\n        address: account.address,\n        meta: account.meta\n      }))\n    });\n  }\n\n  createFromJson(json, meta = {}) {\n    return this.keyring.createFromJson(_objectSpread(_objectSpread({}, json), {}, {\n      meta: _objectSpread(_objectSpread({}, json.meta || {}), {}, {\n        meta\n      })\n    }));\n  }\n\n  createFromUri(suri, meta = {}, type) {\n    return this.keyring.createFromUri(suri, meta, type);\n  }\n\n  encryptAccount(pair, password) {\n    const json = pair.toJson(password);\n    json.meta.whenEdited = Date.now();\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  forgetAccount(address) {\n    this.keyring.removePair(address);\n    this.accounts.remove(this._store, address);\n  }\n\n  forgetAddress(address) {\n    this.addresses.remove(this._store, address);\n  }\n\n  forgetContract(address) {\n    this.contracts.remove(this._store, address);\n  }\n\n  getAccount(address) {\n    return this.getAddress(address, 'account');\n  }\n\n  getAccounts() {\n    const available = this.accounts.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address, 'account')).filter(account => env.isDevelopment() || account.meta.isTesting !== true);\n  }\n\n  getAddress(_address, type = null) {\n    const address = isString(_address) ? _address : this.encodeAddress(_address);\n    const publicKey = this.decodeAddress(address);\n    const stores = type ? [_classPrivateFieldLooseBase(this, _stores)[_stores][type]] : Object.values(_classPrivateFieldLooseBase(this, _stores)[_stores]);\n    const info = stores.reduce((lastInfo, store) => store().subject.getValue()[address] || lastInfo, undefined);\n    return info && {\n      address,\n      meta: info.json.meta,\n      publicKey\n    };\n  }\n\n  getAddresses() {\n    const available = this.addresses.subject.getValue();\n    return Object.keys(available).map(address => this.getAddress(address));\n  }\n\n  getContract(address) {\n    return this.getAddress(address, 'contract');\n  }\n\n  getContracts() {\n    const available = this.contracts.subject.getValue();\n    return Object.entries(available).filter(([, {\n      json: {\n        meta: {\n          contract\n        }\n      }\n    }]) => !!contract && contract.genesisHash === this.genesisHash).map(([address]) => this.getContract(address));\n  }\n\n  rewriteKey(json, key, hexAddr, creator) {\n    if (hexAddr.substr(0, 2) === '0x') {\n      return;\n    }\n\n    this._store.remove(key);\n\n    this._store.set(creator(hexAddr), json);\n  }\n\n  loadAccount(json, key) {\n    if (!json.meta.isTesting && json.encoded) {\n      // FIXME Just for the transition period (ignoreChecksum)\n      const pair = this.keyring.addFromJson(json, true);\n      this.accounts.add(this._store, pair.address, json, pair.type);\n    }\n\n    const [, hexAddr] = key.split(':');\n    this.rewriteKey(json, key, hexAddr.trim(), accountKey);\n  }\n\n  loadAddress(json, key) {\n    const {\n      isRecent,\n      whenCreated = 0\n    } = json.meta;\n\n    if (isRecent && Date.now() - whenCreated > RECENT_EXPIRY) {\n      this._store.remove(key);\n\n      return;\n    } // We assume anything hex that is not 32bytes (64 + 2 bytes hex) is an Ethereum-like address\n    // (this caters for both H160 addresses as well as full or compressed publicKeys) - in the case\n    // of both ecdsa and ethereum, we keep it as-is\n\n\n    const address = isHex(json.address) && json.address.length !== 66 ? json.address : this.encodeAddress(isHex(json.address) ? hexToU8a(json.address) // FIXME Just for the transition period (ignoreChecksum)\n    : this.decodeAddress(json.address, true));\n    const [, hexAddr] = key.split(':');\n    this.addresses.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, addressKey);\n  }\n\n  loadContract(json, key) {\n    const address = this.encodeAddress(this.decodeAddress(json.address));\n    const [, hexAddr] = key.split(':'); // move genesisHash to top-level (TODO Remove from contracts section?)\n\n    json.meta.genesisHash = json.meta.genesisHash || json.meta.contract && json.meta.contract.genesisHash;\n    this.contracts.add(this._store, address, json);\n    this.rewriteKey(json, key, hexAddr, contractKey);\n  }\n\n  loadInjected(address, meta, type) {\n    const json = {\n      address,\n      meta: _objectSpread(_objectSpread({}, meta), {}, {\n        isInjected: true\n      })\n    };\n    const pair = this.keyring.addFromAddress(address, json.meta, null, type);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n  }\n\n  allowGenesis(json) {\n    if (json && json.meta && this.genesisHash) {\n      const hashes = Object.values(chains).find(hashes => hashes.includes(this.genesisHash || '')) || [this.genesisHash];\n\n      if (json.meta.genesisHash) {\n        return hashes.includes(json.meta.genesisHash);\n      } else if (json.meta.contract) {\n        return hashes.includes(json.meta.contract.genesisHash);\n      }\n    }\n\n    return true;\n  }\n\n  loadAll(options, injected = []) {\n    super.initKeyring(options);\n\n    this._store.all((key, json) => {\n      if (options.filter ? options.filter(json) : true) {\n        try {\n          if (this.allowGenesis(json)) {\n            if (accountRegex.test(key)) {\n              this.loadAccount(json, key);\n            } else if (addressRegex.test(key)) {\n              this.loadAddress(json, key);\n            } else if (contractRegex.test(key)) {\n              this.loadContract(json, key);\n            }\n          }\n        } catch (error) {// ignore\n        }\n      }\n    });\n\n    injected.forEach(account => {\n      if (this.allowGenesis(account)) {\n        try {\n          this.loadInjected(account.address, account.meta, account.type);\n        } catch (error) {// ignore\n        }\n      }\n    });\n    this.keyringOption.init(this);\n  }\n\n  restoreAccount(json, password) {\n    const cryptoType = Array.isArray(json.encoding.content) ? json.encoding.content[1] : 'ed25519';\n    const encType = Array.isArray(json.encoding.type) ? json.encoding.type : [json.encoding.type];\n    const pair = createPair({\n      toSS58: this.encodeAddress,\n      type: cryptoType\n    }, {\n      publicKey: this.decodeAddress(json.address, true)\n    }, json.meta, isHex(json.encoded) ? hexToU8a(json.encoded) : base64Decode(json.encoded), encType); // unlock, save account and then lock (locking cleans secretKey, so needs to be last)\n\n    pair.decodePkcs8(password);\n    this.addPair(pair, password);\n    pair.lock();\n    return pair;\n  }\n\n  restoreAccounts(json, password) {\n    const accounts = JSON.parse(u8aToString(jsonDecrypt(json, password)));\n    accounts.forEach(account => {\n      this.loadAccount(account, accountKey(account.address));\n    });\n  }\n\n  saveAccount(pair, password) {\n    this.addTimestamp(pair);\n    const json = pair.toJson(password);\n    this.keyring.addFromJson(json);\n    this.accounts.add(this._store, pair.address, json, pair.type);\n    return json;\n  }\n\n  saveAccountMeta(pair, meta) {\n    const address = pair.address;\n\n    this._store.get(accountKey(address), json => {\n      pair.setMeta(meta);\n      json.meta = pair.meta;\n      this.accounts.add(this._store, address, json, pair.type);\n    });\n  }\n\n  saveAddress(address, meta, type = 'address') {\n    const available = this.addresses.subject.getValue();\n    const json = available[address] && available[address].json || {\n      address,\n      meta: {\n        isRecent: undefined,\n        whenCreated: Date.now()\n      }\n    };\n    Object.keys(meta).forEach(key => {\n      json.meta[key] = meta[key];\n    });\n    delete json.meta.isRecent;\n\n    _classPrivateFieldLooseBase(this, _stores)[_stores][type]().add(this._store, address, json);\n\n    return json;\n  }\n\n  saveContract(address, meta) {\n    return this.saveAddress(address, meta, 'contract');\n  }\n\n  saveRecent(address) {\n    const available = this.addresses.subject.getValue();\n\n    if (!available[address]) {\n      this.addresses.add(this._store, address, {\n        address,\n        meta: {\n          genesisHash: this.genesisHash,\n          isRecent: true,\n          whenCreated: Date.now()\n        }\n      });\n    }\n\n    return this.addresses.subject.getValue()[address];\n  }\n\n}"]},"metadata":{},"sourceType":"module"}